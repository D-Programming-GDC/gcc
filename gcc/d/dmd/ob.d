/**
 * Flow analysis for Ownership/Borrowing
 *
 * Compiler implementation of the
 * $(LINK2 http://www.dlang.org, D programming language).
 *
 * Copyright:   Copyright (C) 1999-2019 by The D Language Foundation, All Rights Reserved
 * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)
 * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/ob.d, _ob.d)
 * Documentation:  https://dlang.org/phobos/dmd_escape.html
 * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/ob.d
 */

module dmd.ob;

import core.stdc.stdio : printf;
import core.stdc.stdlib;
import core.stdc.string;

import dmd.root.array;
import dmd.root.rootobject;
import dmd.root.rmem;

import dmd.aggregate;
import dmd.apply;
import dmd.arraytypes;
import dmd.declaration;
import dmd.dscope;
import dmd.dsymbol;
import dmd.dtemplate;
import dmd.errors;
import dmd.escape;
import dmd.expression;
import dmd.foreachvar;
import dmd.func;
import dmd.globals;
import dmd.identifier;
import dmd.init;
import dmd.mtype;
import dmd.printast;
import dmd.statement;
import dmd.tokens;
import dmd.visitor;

import dmd.root.bitarray;
import dmd.root.outbuffer;

/**********************************
 * Perform ownership/borrowing checks for funcdecl.
 * Does not modify the AST, just checks for errors.
 */

void oblive(FuncDeclaration funcdecl)
{
    //printf("oblive() %s\n", funcdecl.toChars());
    //printf("fbody: %s\n", funcdecl.fbody.toChars());
    ObState obstate;

    /* Build the flow graph
     */
    setLabelStatementExtraFields(funcdecl.labtab);
    toObNodes(obstate.nodes, funcdecl.fbody);
    insertFinallyBlockCalls(obstate.nodes);
    insertFinallyBlockGotos(obstate.nodes);
    removeUnreachable(obstate.nodes);
    computePreds(obstate.nodes);

    numberNodes(obstate.nodes);
    //foreach (ob; obstate.nodes) ob.print();

    collectVars(funcdecl, obstate.vars);
    allocStates(obstate);
    computeGenKill(obstate);
    doDataFlowAnalysis(obstate);

    checkObErrors(obstate);
}

alias ObNodes = Array!(ObNode*);

/*******************************************
 * Collect the state information.
 */
struct ObState
{
    ObNodes nodes;
    VarDeclarations vars;

    Array!size_t varStack;      /// temporary storage
    PtrVarState[] varPool;      /// memory pool

    ~this()
    {
        mem.xfree(varPool.ptr);
    }
}

/***********************************************
 * A node in the function's expression graph, and its edges to predecessors and successors.
 */
struct ObNode
{
    Expression exp;     /// expression for the node
    ObNodes preds;      /// predecessors
    ObNodes succs;      /// successors
    ObNode* tryBlock;   /// try-finally block we're inside
    ObType obtype;
    uint index;         /// index of this in obnodes

    BitArray kill;        /// which variables in ObState.vars get their state replaced by gen
    BitArray comb;        /// which variables in ObState.vars get their state combined with gen
    PtrVarState[] gen;    /// new states generated by exp
    PtrVarState[] input;  /// variable states on entry to exp
    PtrVarState[] output; /// variable states on exit to exp

    this(ObNode* tryBlock)
    {
        this.tryBlock = tryBlock;
    }

    void print()
    {
        printf("%d: %s %s\n", index, obtype.toString.ptr, exp ? exp.toChars() : "-");
        printf("  preds: ");
        foreach (ob; preds)
            printf(" %d", ob.index);
        printf("\n  succs: ");
        foreach (ob; succs)
            printf(" %d", ob.index);
        printf("\n\n");
    }
}


enum ObType : ubyte
{
    goto_,              /// goto one of the succs[]
    return_,            /// returns from function
    retexp,             /// returns expression from function
    throw_,             /// exits with throw
    exit,               /// exits program
    try_,
    finally_,
    fend,
}

string toString(ObType obtype)
{
    return obtype == ObType.goto_     ? "goto  "  :
           obtype == ObType.return_   ? "ret   "  :
           obtype == ObType.retexp    ? "retexp"  :
           obtype == ObType.throw_    ? "throw"   :
           obtype == ObType.exit      ? "exit"    :
           obtype == ObType.try_      ? "try"     :
           obtype == ObType.finally_  ? "finally" :
           obtype == ObType.fend      ? "fend"    :
           "---";
}

/***********
 Pointer variable states:

    Undefined   not in a usable state

                T* p = void;

    Owner       mutable pointer

                T* p = initializer;

    Borrowed    scope mutable pointer, borrowed from [p]

                T* p = initializer;
                scope T* b = p;

    Lent        owner, not usuable while [b] is active

    Readonly    scope const pointer, copied from [p]

                T* p = initializer;
                scope const(T)* cp = p;

    View        owner, const while [cp] is active

 Examples:

    T* p = initializer; // p is owner
    T** pp = &p;        // pp borrows from p

    T* p = initialize;  // p is owner
    T* q = p;           // transfer: q is owner, p is undefined

 Return:

    O,V: Error, should be undefined

 Merge Two Branches:

      U O B L C V
    U U
    O E O
    B E E B
    L E L E L
    C E E C E C
    V E V E E E V

    E: error
 */

enum PtrState : ubyte
{
    Undefined, Owner, Borrowed, Lent, Readonly, View
}

/************
 */
const(char)* toChars(PtrState state)
{
    return ["Undefined", "Owner", "Borrowed", "Lent", "Readonly", "View"][state].ptr;
}

/******
 * Carries the state of a pointer variable.
 */
struct PtrVarState
{
    BitArray deps;           /// dependencies
    PtrState state;          /// state the pointer variable is in

    void opAssign(const ref PtrVarState pvs)
    {
        state = pvs.state;
        deps = pvs.deps;
    }

    /* Combine `this` and `pvs` into `this`,
     * on the idea that the `this` and the `pvs` paths
     * are being merged
     * Params:
     *  pvs = path to be merged with `this`
     */
    void combine(ref PtrVarState pvs)
    {
        static uint X(PtrState x1, PtrState x2) { return x1 * (PtrState.max + 1) + x2; }

        with (PtrState)
        {
            switch (X(state, pvs.state))
            {
                case X(Undefined, Undefined):
                case X(Undefined, Owner    ):
                case X(Undefined, Borrowed ):
                case X(Undefined, Lent     ):
                case X(Undefined, Readonly ):
                case X(Undefined, View     ):
                    break;

                case X(Owner    , Owner   ):
                    break;

                case X(Borrowed , Borrowed):
                case X(Readonly , Readonly):
                case X(View     , View    ):
                case X(Lent     , Lent    ):
                    deps.or(pvs.deps);
                    break;

                case X(Owner    , Lent     ):
                case X(Owner    , View     ):
                case X(Lent     , Owner    ):
                case X(Lent     , View     ):
                case X(View     , Owner    ):
                case X(View     , Lent     ):
                    state = Owner;
                    deps.zero();
                    break;

                default:
                    state = Undefined;
                    deps.zero();
                    break;
            }
        }
    }

    bool opEquals(const ref PtrVarState pvs) const
    {
        return state == pvs.state &&
                deps == pvs.deps;
    }

    /***********************
     */
    void print(VarDeclaration[] vars)
    {
        string s = ["Undefined", "Owner", "Borrowed", "Lent", "Readonly", "View"][state];
        printf("%.*s [", cast(int)s.length, s.ptr);
        assert(vars.length == deps.length);
        OutBuffer buf;
        depsToBuf(buf, vars);
        string t = buf[];
        printf("%.*s]\n", cast(int)t.length, t.ptr);
    }

    /*****************************
     * Produce a user-readable comma separated string of the
     * dependencies.
     * Params:
     *  buf = write resulting string here
     *  vars = array from which to get the variable names
     */
    void depsToBuf(ref OutBuffer buf, const VarDeclaration[] vars)
    {
        bool any = false;
        foreach (i; 0 .. deps.length)
        {
            if (deps[i])
            {
                if (any)
                    buf.writestring(", ");
                buf.writestring(vars[i].toString());
                any = true;
            }
        }
    }
}


/*****************************************
 * Set the `.extra` field for LabelStatements in labtab[].
 */
void setLabelStatementExtraFields(DsymbolTable labtab)
{
    if (labtab)
        foreach (keyValue; labtab.tab.asRange)
        {
            //printf("  KV: %s = %s\n", keyValue.key.toChars(), keyValue.value.toChars());
            auto label = cast(LabelDsymbol)keyValue.value;
            if (label.statement)
                label.statement.extra = cast(void*) new ObNode(null);
        }
}

/*****************************************
 * Convert statement into ObNodes.
 */

void toObNodes(ref ObNodes obnodes, Statement s)
{
    ObNode* breakBlock;
    ObNode* contBlock;
    ObNode* switchBlock;
    ObNode* defaultBlock;
    ObNode* tryBlock;

    ObNode* curblock = new ObNode(tryBlock);
    obnodes.push(curblock);

    void visit(Statement s)
    {
        if (!s)
            return;

        ObNode* newNode()
        {
            return new ObNode(tryBlock);
        }

        ObNode* nextNodeIs(ObNode* ob)
        {
            obnodes.push(ob);
            curblock = ob;
            return ob;
        }

        ObNode* nextNode()
        {
            return nextNodeIs(newNode());
        }

        ObNode* gotoNextNodeIs(ObNode* ob)
        {
            obnodes.push(ob);
            curblock.succs.push(ob);
            curblock = ob;
            return ob;
        }

        // block_goto(blx, BCgoto, null)
        ObNode* gotoNextNode()
        {
            return gotoNextNodeIs(newNode());
        }

        /***
         * Doing a goto to dest
         */
        ObNode* gotoDest(ObNode* dest)
        {
            curblock.succs.push(dest);
            return nextNode();
        }

        void visitExp(ExpStatement s)
        {
            curblock.obtype = ObType.goto_;
            curblock.exp = s.exp;
            gotoNextNode();
        }

        void visitDtorExp(DtorExpStatement s)
        {
            visitExp(s);
        }

        void visitCompound(CompoundStatement s)
        {
            if (s.statements)
            {
                foreach (s2; *s.statements)
                {
                    visit(s2);
                }
            }
        }

        void visitCompoundDeclaration(CompoundDeclarationStatement s)
        {
            visitCompound(s);
        }

        void visitUnrolledLoop(UnrolledLoopStatement s)
        {
            auto breakBlockSave = breakBlock;
            breakBlock = newNode();
            auto contBlockSave = contBlock;

            gotoNextNode();

            foreach (s2; *s.statements)
            {
                if (s2)
                {
                    contBlock = newNode();

                    visit(s2);

                    gotoNextNodeIs(contBlock);
                }
            }

            gotoNextNodeIs(breakBlock);

            contBlock = contBlockSave;
            breakBlock = breakBlockSave;
        }

        void visitScope(ScopeStatement s)
        {
            if (s.statement)
            {
                visit(s.statement);

                if (breakBlock)
                {
                    gotoNextNodeIs(breakBlock);
                }
            }
        }

        void visitDo(DoStatement s)
        {
            auto breakBlockSave = breakBlock;
            auto contBlockSave = contBlock;

            breakBlock = newNode();
            contBlock = newNode();

            auto bpre = curblock;

            auto ob = newNode();
            obnodes.push(ob);
            curblock.succs.push(ob);
            curblock = ob;
            bpre.succs.push(curblock);

            contBlock.succs.push(curblock);
            contBlock.succs.push(breakBlock);

            visit(s._body);

            gotoNextNodeIs(contBlock);
            contBlock.exp = s.condition;
            nextNodeIs(breakBlock);

            contBlock = contBlockSave;
            breakBlock = breakBlockSave;
        }

        void visitFor(ForStatement s)
        {
            //printf("visit(ForStatement)) %u..%u\n", s.loc.linnum, s.endloc.linnum);
            auto breakBlockSave = breakBlock;
            auto contBlockSave = contBlock;

            breakBlock = newNode();
            contBlock = newNode();

            visit(s._init);

            auto bcond = gotoNextNode();
            contBlock.succs.push(bcond);

            if (s.condition)
            {
                bcond.exp = s.condition;
                auto ob = newNode();
                obnodes.push(ob);
                bcond.succs.push(ob);
                bcond.succs.push(breakBlock);
                curblock = ob;
            }
            else
            {   /* No conditional, it's a straight goto
                 */
                bcond.exp = s.condition;
                bcond.succs.push(nextNode());
            }

            visit(s._body);
            /* End of the body goes to the continue block
             */
            curblock.succs.push(contBlock);
            nextNodeIs(contBlock);

            if (s.increment)
                curblock.exp = s.increment;

            /* The 'break' block follows the for statement.
             */
            nextNodeIs(breakBlock);

            contBlock = contBlockSave;
            breakBlock = breakBlockSave;
        }

        void visitIf(IfStatement s)
        {
            // bexit is the block that gets control after this IfStatement is done
            auto bexit = breakBlock ? breakBlock : newNode();

            curblock.exp = s.condition;

            auto bcond = curblock;
            gotoNextNode();

            visit(s.ifbody);
            curblock.succs.push(bexit);

            if (s.elsebody)
            {
                bcond.succs.push(nextNode());

                visit(s.elsebody);

                gotoNextNodeIs(bexit);
            }
            else
            {
                bcond.succs.push(bexit);
                nextNodeIs(bexit);
            }
        }

        void visitSwitch(SwitchStatement s)
        {
            auto breakBlockSave = breakBlock;
            auto switchBlockSave = switchBlock;
            auto defaultBlockSave = defaultBlock;

            switchBlock = curblock;

            /* Block for where "break" goes to
             */
            breakBlock = newNode();

            /* Block for where "default" goes to.
             * If there is a default statement, then that is where default goes.
             * If not, then do:
             *   default: break;
             * by making the default block the same as the break block.
             */
            defaultBlock = s.sdefault ? newNode() : breakBlock;

            const numcases = s.cases ? s.cases.dim : 0;

            /* allocate a block for each case
             */
            if (numcases)
                foreach (cs; *s.cases)
                {
                    cs.extra = cast(void*)newNode();
                }

            curblock.exp = s.condition;

            if (s.hasVars)
            {   /* Generate a sequence of if-then-else blocks for the cases.
                 */
                if (numcases)
                    foreach (cs; *s.cases)
                    {
                        auto ecase = newNode();
                        obnodes.push(ecase);
                        ecase.exp = cs.exp;
                        curblock.succs.push(ecase);

                        auto cn = cast(ObNode*)cs.extra;
                        ecase.succs.push(cn);
                        ecase.succs.push(nextNode());
                    }

                /* The final 'else' clause goes to the default
                 */
                curblock.succs.push(defaultBlock);
                nextNode();

                visit(s._body);

                /* Have the end of the switch body fall through to the block
                 * following the switch statement.
                 */
                gotoNextNodeIs(breakBlock);

                breakBlock = breakBlockSave;
                switchBlock = switchBlockSave;
                defaultBlock = defaultBlockSave;
                return;
            }

            auto ob = newNode();
            obnodes.push(ob);
            curblock = ob;

            switchBlock.succs.push(defaultBlock);

            visit(s._body);

            /* Have the end of the switch body fall through to the block
             * following the switch statement.
             */
            gotoNextNodeIs(breakBlock);

            breakBlock = breakBlockSave;
            switchBlock = switchBlockSave;
            defaultBlock = defaultBlockSave;
        }

        void visitCase(CaseStatement s)
        {
            auto cb = cast(ObNode*)s.extra;
            cb.tryBlock = tryBlock;
            switchBlock.succs.push(cb);
            cb.tryBlock = tryBlock;
            gotoNextNodeIs(cb);

            visit(s.statement);
        }

        void visitDefault(DefaultStatement s)
        {
            defaultBlock.tryBlock = tryBlock;
            gotoNextNodeIs(defaultBlock);
            visit(s.statement);
        }

        void visitGotoDefault(GotoDefaultStatement s)
        {
            gotoDest(defaultBlock);
        }

        void visitGotoCase(GotoCaseStatement s)
        {
            gotoDest(cast(ObNode*)s.cs.extra);
        }

        void visitSwitchError(SwitchErrorStatement s)
        {
            curblock.obtype = ObType.throw_;
            curblock.exp = s.exp;

            nextNode();
        }

        void visitReturn(ReturnStatement s)
        {
            //printf("visitReturn() %s\n", s.toChars());
            curblock.obtype = s.exp && s.exp.type.toBasetype().ty != Tvoid
                        ? ObType.retexp
                        : ObType.return_;
            curblock.exp = s.exp;

            nextNode();
        }

        void visitBreak(BreakStatement s)
        {
            gotoDest(breakBlock);
        }

        void visitContinue(ContinueStatement s)
        {
            gotoDest(contBlock);
        }

        void visitWith(WithStatement s)
        {
            visit(s._body);
        }

        void visitTryCatch(TryCatchStatement s)
        {
            /* tryblock
             * body
             * breakBlock
             * catches
             * breakBlock2
             */

            auto breakBlockSave = breakBlock;
            breakBlock = newNode();

            auto tryblock = gotoNextNode();

            visit(s._body);

            gotoNextNodeIs(breakBlock);

            // create new break block that follows all the catches
            auto breakBlock2 = newNode();

            gotoDest(breakBlock2);

            foreach (cs; *s.catches)
            {
                /* Each catch block is a successor to tryblock
                 * and the last block of try body
                 */
                auto bcatch = curblock;
                tryblock.succs.push(bcatch);
                breakBlock.succs.push(bcatch);

                nextNode();

                visit(cs.handler);

                gotoDest(breakBlock2);
            }

            curblock.succs.push(breakBlock2);
            obnodes.push(breakBlock2);
            curblock = breakBlock2;

            breakBlock = breakBlockSave;
        }

        void visitTryFinally(TryFinallyStatement s)
        {
            /* Build this:
             *  1  goto     [2]
             *  2  try_     [3] [5] [7]
             *  3  body
             *  4  goto     [8]
             *  5  finally_ [6]
             *  6  finalbody
             *  7  fend     [8]
             *  8  lastblock
             */

            auto b2 = gotoNextNode();
            b2.obtype = ObType.try_;
            tryBlock = b2;

            gotoNextNode();

            visit(s._body);

            auto b4 = gotoNextNode();

            tryBlock = b2.tryBlock;

            auto b5 = newNode();
            b5.obtype = ObType.finally_;
            nextNodeIs(b5);
            gotoNextNode();

            visit(s.finalbody);

            auto b7 = gotoNextNode();
            b7.obtype = ObType.fend;

            auto b8 = gotoNextNode();

            b2.succs.push(b5);
            b2.succs.push(b7);

            b4.succs.push(b8);
        }

        void visitThrow(ThrowStatement s)
        {
            curblock.obtype = ObType.throw_;
            curblock.exp = s.exp;
            nextNode();
        }

        void visitGoto(GotoStatement s)
        {
            gotoDest(cast(ObNode*)s.label.statement.extra);
        }

        void visitLabel(LabelStatement s)
        {
            auto ob = cast(ObNode*)s.extra;
            ob.tryBlock = tryBlock;
            visit(s.statement);
        }

        final switch (s.stmt)
        {
            case STMT.Exp:                 visitExp(s.isExpStatement()); break;
            case STMT.DtorExp:             visitDtorExp(s.isDtorExpStatement()); break;
            case STMT.Compound:            visitCompound(s.isCompoundStatement()); break;
            case STMT.CompoundDeclaration: visitCompoundDeclaration(s.isCompoundDeclarationStatement()); break;
            case STMT.UnrolledLoop:        visitUnrolledLoop(s.isUnrolledLoopStatement()); break;
            case STMT.Scope:               visitScope(s.isScopeStatement()); break;
            case STMT.Do:                  visitDo(s.isDoStatement()); break;
            case STMT.For:                 visitFor(s.isForStatement()); break;
            case STMT.If:                  visitIf(s.isIfStatement()); break;
            case STMT.Switch:              visitSwitch(s.isSwitchStatement()); break;
            case STMT.Case:                visitCase(s.isCaseStatement()); break;
            case STMT.Default:             visitDefault(s.isDefaultStatement()); break;
            case STMT.GotoDefault:         visitGotoDefault(s.isGotoDefaultStatement()); break;
            case STMT.GotoCase:            visitGotoCase(s.isGotoCaseStatement()); break;
            case STMT.SwitchError:         visitSwitchError(s.isSwitchErrorStatement()); break;
            case STMT.Return:              visitReturn(s.isReturnStatement()); break;
            case STMT.Break:               visitBreak(s.isBreakStatement()); break;
            case STMT.Continue:            visitContinue(s.isContinueStatement()); break;
            case STMT.With:                visitWith(s.isWithStatement()); break;
            case STMT.TryCatch:            visitTryCatch(s.isTryCatchStatement()); break;
            case STMT.TryFinally:          visitTryFinally(s.isTryFinallyStatement()); break;
            case STMT.Throw:               visitThrow(s.isThrowStatement()); break;
            case STMT.Goto:                visitGoto(s.isGotoStatement()); break;
            case STMT.Label:               visitLabel(s.isLabelStatement()); break;

            case STMT.CompoundAsm:
            case STMT.Asm:
            case STMT.InlineAsm:
            case STMT.GccAsm:

            case STMT.Pragma:
            case STMT.Import:
            case STMT.ScopeGuard:
            case STMT.Error:
                break;          // ignore these

            case STMT.Foreach:
            case STMT.ForeachRange:
            case STMT.Debug:
            case STMT.CaseRange:
            case STMT.StaticForeach:
            case STMT.StaticAssert:
            case STMT.Conditional:
            case STMT.While:
            case STMT.Forwarding:
            case STMT.Compile:
            case STMT.Peel:
            case STMT.Synchronized:
                debug printf("s: %s\n", s.toChars());
                assert(0);              // should have been rewritten
        }
    }

    visit(s);
    curblock.obtype = ObType.return_;

    assert(breakBlock is null);
    assert(contBlock is null);
    assert(switchBlock is null);
    assert(defaultBlock is null);
    assert(tryBlock is null);
}

/***************************************************
 * Insert finally block calls when doing a goto from
 * inside a try block to outside.
 * Done after blocks are generated because then we know all
 * the edges of the graph, but before the pred's are computed.
 * Params:
 *      obnodes = graph of the function
 */

void insertFinallyBlockCalls(ref ObNodes obnodes)
{
    ObNode* bcret = null;
    ObNode* bcretexp = null;

    enum log = false;

    static if (log)
    {
        printf("------- before ----------\n");
        numberNodes(obnodes);
        foreach (ob; obnodes) ob.print();
        printf("-------------------------\n");
    }

    foreach (ob; obnodes)
    {
        if (!ob.tryBlock)
            continue;

        switch (ob.obtype)
        {
            case ObType.return_:
                // Rewrite into a ObType.goto_ => ObType.return_
                if (!bcret)
                {
                    bcret = new ObNode();
                    bcret.obtype = ob.obtype;
                }
                ob.obtype = ObType.goto_;
                ob.succs.push(bcret);
                goto case_goto;

            case ObType.retexp:
                // Rewrite into a ObType.goto_ => ObType.retexp
                if (!bcretexp)
                {
                    bcretexp = new ObNode();
                    bcretexp.obtype = ob.obtype;
                }
                ob.obtype = ObType.goto_;
                ob.succs.push(bcretexp);
                goto case_goto;

            case ObType.goto_:
                if (ob.succs.length != 1)
                    break;

            case_goto:
            {
                auto target = ob.succs[0];              // destination of goto
                ob.succs.setDim(0);
                auto lasttry = target.tryBlock;
                auto blast = ob;
                for (auto bt = ob.tryBlock; bt != lasttry; bt = bt.tryBlock)
                {
                    assert(bt.obtype == ObType.try_);
                    auto bf = bt.succs[1];
                    assert(bf.obtype == ObType.finally_);
                    auto bfend = bt.succs[2];
                    assert(bfend.obtype == ObType.fend);

                    if (!blast.succs.contains(bf.succs[0]))
                        blast.succs.push(bf.succs[0]);

                    blast = bfend;
                }
                if (!blast.succs.contains(target))
                    blast.succs.push(target);

                break;
            }

            default:
                break;
        }
    }
    if (bcret)
        obnodes.push(bcret);
    if (bcretexp)
        obnodes.push(bcretexp);

    static if (log)
    {
        printf("------- after ----------\n");
        numberNodes(obnodes);
        foreach (ob; obnodes) ob.print();
        printf("-------------------------\n");
    }
}

/***************************************************
 * Remove try-finally scaffolding.
 * Params:
 *      obnodes = nodes for the function
 */

void insertFinallyBlockGotos(ref ObNodes obnodes)
{
    /* Remove all the try_, finally_, lpad and ret nodes.
     * Actually, just make them into no-ops.
     */
    foreach (ob; obnodes)
    {
        ob.tryBlock = null;
        switch (ob.obtype)
        {
            case ObType.try_:
                ob.obtype = ObType.goto_;
                ob.succs.remove(2);     // remove fend
                ob.succs.remove(1);     // remove finally_
                break;

            case ObType.finally_:
                ob.obtype = ObType.goto_;
                break;

            case ObType.fend:
                ob.obtype = ObType.goto_;
                break;

            default:
                break;
        }
    }
}

/*********************************
 * Set the `index` field of each ObNode
 * to its index in the array.
 */
void numberNodes(ref ObNodes obnodes)
{
    foreach (i, ob; obnodes)
    {
        ob.index = cast(uint)i;
    }
}


/*********************************
 * Remove unreachable nodes and compress
 * them out of obnodes[].
 * Params:
 *      obnodes = array of nodes
 */
void removeUnreachable(ref ObNodes obnodes)
{
    if (!obnodes.length)
        return;

    /* Mark all nodes as unreachable,
     * temporarilly reusing ObNode.index
     */
    foreach (ob; obnodes)
        ob.index = 0;

    /* Recurseively mark ob and all its successors as reachable
     */
    static void mark(ObNode* ob)
    {
        ob.index = 1;
        foreach (succ; ob.succs)
        {
            if (!succ.index)
                mark(succ);
        }
    }

    mark(obnodes[0]);   // first node is entry point

    /* Remove unreachable nodes by shifting the remainder left
     */
    size_t j = 1;
    foreach (i; 1 .. obnodes.length)
    {
        if (obnodes[i].index)
        {
            if (i != j)
                obnodes[j] = obnodes[i];
            ++j;
        }
        else
        {
            obnodes[i].destroy();
        }
    }
    obnodes.setDim(j);
}



/*************************************
 * Compute predecessors.
 */
void computePreds(ref ObNodes obnodes)
{
    foreach (ob; obnodes)
    {
        foreach (succ; ob.succs)
        {
            succ.preds.push(ob);
        }
    }
}

/*******************************
 * Are we interested in tracking this variable?
 */
bool isTrackableVar(VarDeclaration v)
{
    /* Currently only dealing with pointers
     */
    if (v.type.toBasetype().ty != Tpointer)
        return false;
    if (v.needsScopeDtor())
        return false;
    if (v.storage_class & STC.parameter && !v.type.isMutable())
        return false;
    return !v.isDataseg();
}

/*******************************
 * Are we interested in tracking this expression?
 * Returns:
 *      variable if so, null if not
 */
VarDeclaration isTrackableVarExp(Expression e)
{
    if (auto ve = e.isVarExp())
    {
        if (auto v = ve.var.isVarDeclaration())
            if (isTrackableVar(v))
                return v;
    }
    return null;
}


/**************
 * Find the pointer variable declarations in this function,
 * and fill `vars` with them.
 * Params:
 *      funcdecl = function we are in
 *      vars = array to fill in
 */
void collectVars(FuncDeclaration funcdecl, out VarDeclarations vars)
{
    enum log = false;
    if (log)
        printf("----------------collectVars()---------------\n");

    if (funcdecl.parameters)
        foreach (v; (*funcdecl.parameters)[])
        {
            if (isTrackableVar(v))
                vars.push(v);
        }

    void dgVar(VarDeclaration v)
    {
        if (isTrackableVar(v))
            vars.push(v);
    }

    void dgExp(Expression e)
    {
        foreachVar(e, &dgVar);
    }

    foreachExpAndVar(funcdecl.fbody, &dgExp, &dgVar);

    static if (log)
    {
        foreach (i, v; vars[])
        {
            printf("vars[%d] = %s\n", cast(int)i, v.toChars());
        }
    }
}

/***********************************
 * Allocate BitArrays in PtrVarState.
 * Can be allocated much more efficiently by subdividing a single
 * large array of bits
 */
void allocDeps(PtrVarState[] pvss)
{
    //printf("allocDeps()\n");
    foreach (ref pvs; pvss)
    {
        pvs.deps.length = pvss.length;
    }
}


/**************************************
 * Allocate state variables foreach node.
 */
void allocStates(ref ObState obstate)
{
    //printf("---------------allocStates()------------------\n");
    const vlen = obstate.vars.length;
    PtrVarState* p = cast(PtrVarState*) mem.xcalloc(obstate.nodes.length * 3 * vlen, PtrVarState.sizeof);
    obstate.varPool = p[0 .. obstate.nodes.length * 3 * vlen];
    foreach (i, ob; obstate.nodes)
    {
        //printf(" [%d]\n", cast(int)i);
        ob.kill.length = obstate.vars.length;
        ob.comb.length = obstate.vars.length;
        ob.gen         = p[0 .. vlen]; p += vlen;
        ob.input       = p[0 .. vlen]; p += vlen;
        ob.output      = p[0 .. vlen]; p += vlen;

        allocDeps(ob.gen);
        allocDeps(ob.input);
        allocDeps(ob.output);
    }
}

/******************************
 * Does v meet the definiton of a `Borrowed` pointer?
 * Returns:
 *      true if it does
 */
bool isBorrowedPtr(VarDeclaration v)
{
    return v.isScope() && !v.isowner && v.type.nextOf().isMutable();
}

/******************************
 * Does v meet the definiton of a `Readonly` pointer?
 * Returns:
 *      true if it does
 */
bool isReadonlyPtr(VarDeclaration v)
{
    return v.isScope() && !v.type.nextOf().isMutable();
}

/***************************************
 * Compute the gen/comb/kill vectors for each node.
 */
void computeGenKill(ref ObState obstate)
{
    enum log = false;
    if (log)
        printf("-----------computeGenKill()-----------\n");

    /***************
     * Assigning result of expression to variable.
     */
    void dgWriteVar(ObNode* ob, VarDeclaration v, Expression e, bool initializer)
    {
        const i = obstate.vars.find(v);
        assert(i != size_t.max);
        ob.kill[i] = true;
        PtrVarState* pvs = &ob.gen[i];
        if (e)
        {
            if (isBorrowedPtr(v))
                pvs.state = PtrState.Borrowed;
            else if (isReadonlyPtr(v))
                pvs.state = PtrState.Readonly;
            else
                pvs.state = PtrState.Owner;
            pvs.deps.zero();

            EscapeByResults er;
            escapeByValue(e, &er);
            bool any = false;           // if any variables are assigned to v

            void by(VarDeclaration r)
            {
                const ri = obstate.vars.find(r);
                if (ri != size_t.max)
                {
                    pvs.deps[ri] = true;         // v took from r
                    auto pvsr = &ob.gen[ri];
                    any = true;

                    if (isBorrowedPtr(v))
                    {
                        // v is borrowing from r
                        pvs.state = PtrState.Borrowed;
                        pvsr.state = PtrState.Lent;
                        pvsr.deps.zero();           // previous borrows are now invalid
                        pvsr.deps[i] = true;        // r was lent to v
                        ob.kill[ri] = true;
                    }
                    else if (isReadonlyPtr(v))
                    {
                        pvs.state = PtrState.Readonly;
                        if (pvsr.state == PtrState.View)
                        {
                            pvsr.deps[i] = true;        // r was lent to v
                            ob.comb[ri] = true;
                        }
                        else
                        {
                            pvsr.deps.zero();       // previous borrows are now invalid
                            pvsr.state = PtrState.View;
                            pvsr.deps[i] = true;        // r was lent to v
                            ob.comb[ri] = true;
                        }
                    }
                    else
                    {
                        // move from r to v
                        pvsr.state = PtrState.Undefined;
                        pvsr.deps.zero();
                        ob.kill[ri] = true;
                        /* Perhaps move every one who borrowed from r to
                         * borrowing from v?
                         */
                    }
                }
            }

            foreach (VarDeclaration v2; er.byvalue)
                by(v2);
            foreach (VarDeclaration v2; er.byref)
                by(v2);

            /* Make v an Owner for initializations like:
             *    scope v = malloc();
             */
            if (initializer && !any && isBorrowedPtr(v))
            {
                v.isowner = true;
                pvs.state = PtrState.Owner;
            }
        }
        else
        {
            pvs.state = PtrState.Undefined;
            pvs.deps.zero();
        }
    }

    void dgReadVar(const ref Loc loc, ObNode* ob, VarDeclaration v, Type t)
    {
        if (log)
            printf("dgReadVar() %s %s\n", v.toChars(), t.toChars());
        const i = obstate.vars.find(v);
        assert(i != size_t.max);
        auto pvs = &ob.gen[i];
        if (isBorrowedPtr(v))
        { }
        else if (isReadonlyPtr(v))
        {
        }
        else
        {
            if (t.toBasetype().nextOf().isMutable())
            {
                pvs.state = PtrState.Owner;
                pvs.deps.zero();        // borrowers become invalid
                ob.kill[i] = true;
            }
        }
    }

    void foreachExp(ObNode* ob, Expression e)
    {
        extern (C++) final class ExpWalker : Visitor
        {
            alias visit = typeof(super).visit;
            extern (D) void delegate(ObNode*, VarDeclaration, Expression, bool) dgWriteVar;
            extern (D) void delegate(const ref Loc loc, ObNode* ob, VarDeclaration v, Type t) dgReadVar;
            ObNode* ob;
            ObState* obstate;

            extern (D) this(void delegate(ObNode*, VarDeclaration, Expression, bool) dgWriteVar,
                            void delegate(const ref Loc loc, ObNode* ob, VarDeclaration v, Type t) dgReadVar,
                            ObNode* ob, ref ObState obstate)
            {
                this.dgWriteVar = dgWriteVar;
                this.dgReadVar  = dgReadVar;
                this.ob = ob;
                this.obstate = &obstate;
            }

            override void visit(Expression e)
            {
                //printf("[%s] %s: %s\n", e.loc.toChars(), Token.toChars(e.op), e.toChars());
                //assert(0);
            }

            void visitAssign(AssignExp ae, bool initializer)
            {
                ae.e2.accept(this);
                if (auto ve = ae.e1.isVarExp())
                {
                    if (auto v = ve.var.isVarDeclaration())
                        if (isTrackableVar(v))
                            dgWriteVar(ob, v, ae.e2, initializer);
                }
                else
                    ae.e1.accept(this);
            }

            override void visit(AssignExp ae)
            {
                visitAssign(ae, false);
            }

            override void visit(DeclarationExp e)
            {
                void Dsymbol_visit(Dsymbol s)
                {
                    if (auto vd = s.isVarDeclaration())
                    {
                        s = s.toAlias();
                        if (s != vd)
                            return Dsymbol_visit(s);
                        if (!isTrackableVar(vd))
                            return;

                        auto ei = vd._init ? vd._init.isExpInitializer() : null;
                        if (ei)
                            visitAssign(cast(AssignExp)ei.exp, true);
                        else
                            dgWriteVar(ob, vd, null, false);
                    }
                    else if (auto td = s.isTupleDeclaration())
                    {
                        foreach (o; *td.objects)
                        {
                            if (auto eo = o.isExpression())
                            {
                                if (auto se = eo.isDsymbolExp())
                                {
                                    Dsymbol_visit(se.s);
                                }
                            }
                        }
                    }
                }

                Dsymbol_visit(e.declaration);
            }

            override void visit(VarExp ve)
            {
                //printf("VarExp: %s\n", ve.toChars());
                if (auto v = ve.var.isVarDeclaration())
                    if (isTrackableVar(v))
                    {
                        dgReadVar(ve.loc, ob, v, ve.type);
                    }
            }

            override void visit(CallExp ce)
            {
                //printf("CallExp() %s\n", ce.toChars());
                ce.e1.accept(this);
                auto t = ce.e1.type.toBasetype();
                auto tf = t.isTypeFunction();
                if (!tf)
                {
                    assert(t.ty == Tdelegate);
                    tf = t.nextOf().isTypeFunction();
                    assert(tf);
                }

                // j=1 if _arguments[] is first argument
                const int j = tf.isDstyleVariadic();
                bool hasOut;
                const varStackSave = obstate.varStack.length;

                foreach (const i, arg; (*ce.arguments)[])
                {
                    arg.accept(this);
                    if (i - j < tf.parameterList.length &&
                        i >= j)
                    {
                        Parameter p = tf.parameterList[i - j];

                        EscapeByResults er;
                        escapeByValue(arg, &er);

                        void by(VarDeclaration v)
                        {
                            if (!isTrackableVar(v))
                                return;

                            const vi = obstate.vars.find(v);
                            if (vi == size_t.max)
                                return;

                            auto pvs = &ob.gen[vi];

                            if (p.storageClass & STC.out_)
                            {
                                hasOut = true;
                                pvs.state = PtrState.Undefined;
                                pvs.deps.zero();
                                ob.kill[vi] = true;
                            }
                            else if (p.storageClass & STC.scope_)
                            {
                                //printf("test1 v: %s p: %s type: %s\n", v.toChars(), p.toChars(), p.type.toChars());
                                auto t = p.type.toBasetype();
                                if (!t.nextOf() && t.isMutable() || t.nextOf().isMutable())
                                {
                                    // borrow from v
                                    pvs.state = PtrState.Borrowed;
                                    pvs.deps.zero();
                                    ob.kill[vi] = true;
                                    obstate.varStack.push(vi);
                                }
                                else
                                {
                                    // readonly
                                    // borrow from v
                                    pvs.state = PtrState.Readonly;
                                    pvs.deps.zero();
                                    ob.kill[vi] = true;
                                    obstate.varStack.push(vi);
                                }
                            }
                            else
                            {
                                // move (i.e. consuming arg)
                                pvs.state = PtrState.Undefined;
                                pvs.deps.zero();
                                ob.kill[vi] = true;
                            }
                        }

                        foreach (VarDeclaration v2; er.byvalue)
                            by(v2);
                        foreach (VarDeclaration v2; er.byref)
                            by(v2);
                    }
                }

                /* Reset variables that were borrowed by the function call
                 */
                foreach (i; obstate.varStack[varStackSave .. obstate.varStack.length])
                {
                    auto pvs = &ob.gen[i];
                    if (pvs.state == PtrState.Borrowed ||
                        pvs.state == PtrState.Readonly && !pvs.deps.isZero())
                    {
                        pvs.state = PtrState.Owner;
                        pvs.deps.zero();
                        ob.kill[i] = true;
                    }
                }
                obstate.varStack.setDim(varStackSave);

                if (hasOut)
                    // Initialization of out's only happens after the function call
                    foreach (const i, arg; (*ce.arguments)[])
                    {
                        if (i - j < tf.parameterList.length &&
                            i >= j)
                        {
                            Parameter p = tf.parameterList[i - j];
                            if (p.storageClass & STC.out_)
                            {
                                if (auto v = isTrackableVarExp(arg))
                                    dgWriteVar(ob, v, null, false);
                            }
                        }
                    }
            }

            override void visit(SymOffExp e)
            {
                if (auto v = e.var.isVarDeclaration())
                    if (isTrackableVar(v))
                    {
                        dgReadVar(e.loc, ob, v, e.type);
                    }
            }

            override void visit(LogicalExp e)
            {
                e.e1.accept(this);

                const vlen = obstate.vars.length;
                auto p = cast(PtrVarState*)mem.xcalloc(vlen, PtrVarState.sizeof);
                PtrVarState[] gen1 = p[0 .. vlen];
                foreach (i, ref pvs; gen1)
                {
                    pvs = ob.gen[i];
                }

                BitArray kill1;
                kill1 = ob.kill;
                BitArray comb1;
                comb1 = ob.comb;

                e.e2.accept(this);

                // Merge gen1 into ob.gen
                foreach (i; 0 .. vlen)
                {
                    if (ob.kill[i])
                    {
                        if (!kill1[i] ||
                           gen1[i].state != ob.gen[i].state ||
                           gen1[i].deps != ob.gen[i].deps)
                        {
                            ob.gen[i].state = PtrState.Undefined;
                            ob.gen[i].deps.zero();
                        }
                    }
                    else if (ob.comb[i])
                    {
                        if (!comb1[i] ||
                           gen1[i].state != ob.gen[i].state)
                        {
                            ob.gen[i].state = PtrState.Undefined;
                            ob.gen[i].deps.zero();
                        }
                    }
                }

                mem.xfree(p); // should free .deps too
            }

            override void visit(CondExp e)
            {
                e.econd.accept(this);

                const vlen = obstate.vars.length;
                auto p = cast(PtrVarState*)mem.xcalloc(vlen, PtrVarState.sizeof);
                PtrVarState[] gen1 = p[0 .. vlen];
                foreach (i, ref pvs; gen1)
                {
                    pvs = ob.gen[i];
                }

                BitArray kill1;
                kill1 = ob.kill;
                BitArray comb1;
                comb1 = ob.comb;

                e.e1.accept(this);

                // Swap gen1,kill1,comb1 with ob.gen,ob.kill1,ob.comb1
                kill1.swap(ob.kill);
                comb1.swap(ob.comb);
                foreach (i; 0 .. vlen)
                {
                    gen1[i].deps.swap(ob.gen[i].deps);
                    const state = gen1[i].state;
                    gen1[i].state = ob.gen[i].state;
                    ob.gen[i].state = state;
                }

                e.e2.accept(this);

                // Merge gen1 into ob.gen
                foreach (i; 0 .. vlen)
                {
                    if (ob.kill[i])
                    {
                        if (!kill1[i] ||
                           gen1[i].state != ob.gen[i].state ||
                           gen1[i].deps != ob.gen[i].deps)
                        {
                            ob.gen[i].state = PtrState.Undefined;
                            ob.gen[i].deps.zero();
                        }
                    }
                    else if (ob.comb[i])
                    {
                        if (!comb1[i] ||
                           gen1[i].state != ob.gen[i].state)
                        {
                            ob.gen[i].state = PtrState.Undefined;
                            ob.gen[i].deps.zero();
                        }
                    }
                }

                mem.xfree(p); // should free .deps too
            }

            override void visit(AddrExp e)
            {
                /* Taking the address of struct literal is normally not
                 * allowed, but CTFE can generate one out of a new expression,
                 * but it'll be placed in static data so no need to check it.
                 */
                if (e.e1.op != TOK.structLiteral)
                    e.e1.accept(this);
            }

            override void visit(UnaExp e)
            {
                e.e1.accept(this);
            }

            override void visit(BinExp e)
            {
                e.e1.accept(this);
                e.e2.accept(this);
            }

            override void visit(ArrayLiteralExp e)
            {
                Type tb = e.type.toBasetype();
                if (tb.ty == Tsarray || tb.ty == Tarray)
                {
                    if (e.basis)
                        e.basis.accept(this);
                    foreach (el; *e.elements)
                    {
                        if (el)
                            el.accept(this);
                    }
                }
            }

            override void visit(StructLiteralExp e)
            {
                if (e.elements)
                {
                    foreach (ex; *e.elements)
                    {
                        if (ex)
                            ex.accept(this);
                    }
                }
            }

            override void visit(AssocArrayLiteralExp e)
            {
                if (e.keys)
                {
                    foreach (i, key; *e.keys)
                    {
                        if (key)
                            key.accept(this);
                        if (auto value = (*e.values)[i])
                            value.accept(this);
                    }
                }
            }

            override void visit(NewExp e)
            {
                Type tb = e.newtype.toBasetype();
                if (e.arguments)
                {
                    foreach (ex; *e.arguments)
                    {
                        if (ex)
                            ex.accept(this);
                    }
                }
            }

            override void visit(SliceExp e)
            {
                e.e1.accept(this);
                if (e.lwr)
                    e.lwr.accept(this);
                if (e.upr)
                    e.upr.accept(this);
            }
        }

        if (e)
        {
            scope ExpWalker ew = new ExpWalker(&dgWriteVar, &dgReadVar, ob, obstate);
            e.accept(ew);
        }
    }

    foreach (obi, ob; obstate.nodes)
    {
        foreachExp(ob, ob.exp);

        static if (log)
        {
            printf("%d: %s\n", obi, ob.exp ? ob.exp.toChars() : "".ptr);
            printf("  gen:\n");
            foreach (i; 0 .. ob.kill.length)
            {
                if (ob.kill[i] | ob.comb[i])
                {
                    auto psv = &ob.gen[i];
                    printf("    %s: ", obstate.vars[i].toChars());
                    if (!ob.kill[i])
                        printf("comb : ");
                    psv.print(obstate.vars[]);
                }
            }
        }
    }
}

/***************************************
 * Determine the state of a variable based on
 * its type and storage class.
 */
PtrState toPtrState(VarDeclaration v)
{
    /* pointer to mutable:        Owner
     * pointer to mutable, scope: Borrowed
     * pointer to const:          Owner
     * pointer to const, scope:   Readonly
     * ref:                       Borrowed
     * const ref:                 Readonly
     */
    auto tb = v.type.toBasetype();
    if (v.isRef())
    {
        return tb.isMutable() ? PtrState.Borrowed : PtrState.Readonly;
    }
    auto tp = tb.isTypePointer();
    assert(tp);
    if (v.isScope())
    {
        return tp.nextOf().isMutable() ? PtrState.Borrowed : PtrState.Readonly;
    }
    else
        return PtrState.Owner;
}


/***************************************
 * Do the data flow analysis (i.e. compute the input[]
 * and output[] vectors for each node).
 */
void doDataFlowAnalysis(ref ObState obstate)
{
    enum log = false;
    if (log)
        printf("-----------------doDataFlowAnalysis()-------------------------\n");

    if (!obstate.nodes.length)
        return;

    auto startnode = obstate.nodes[0];
    assert(startnode.preds.length == 0);

    /* Set opening state for first node
     */
    foreach (i, ref ps; startnode.input)
    {
        auto v = obstate.vars[i];
        auto state = toPtrState(v);
        if (v.isParameter())
        {
            if (v.isOut())
                state = PtrState.Undefined;
        }
        else
            state = PtrState.Undefined;
        ps.state = state;
    }

    /* Set all output[]s to Undefined
     */
    foreach (n; obstate.nodes[])
    {
        foreach (ref ps; n.output)
        {
            ps.state = PtrState.Undefined;
            ps.deps.zero();
        }
    }

    const vlen = obstate.vars.length;
    PtrVarState pvs;
    pvs.deps.length = vlen;
    int counter = 0;
    bool changes;
    do
    {
        changes = false;
        assert(++counter <= 1000);      // should converge, but don't hang if it doesn't
        foreach (n; obstate.nodes[])
        {
            /* Construct n.input[] by combining the .output[]s of each n.preds[]
             */
            if (n != startnode)
            {
                foreach (i; 0 .. vlen)
                {
                    foreach (j; 0 .. n.preds.length)
                    {
                        if (j == 0)
                            pvs = n.preds[j].output[i];
                        else
                            pvs.combine(n.preds[j].output[i]);
                    }
                    if (pvs != n.input[i])
                    {
                        n.input[i] = pvs;
                        changes = true;
                    }
                }
            }

            /* Construct n.output[] by combining n.input[] with n.kill and n.gen[]
             */
            foreach (i; 0 .. vlen)
            {
                pvs = n.output[i];
                if (n.kill[i])
                    n.output[i] = n.gen[i];
                else if (n.comb[i])
                {   // combine input with gen
                    n.output[i] = n.input[i];
                    n.output[i].state = n.gen[i].state;
                    n.output[i].combine(n.gen[i]);
                }
                else
                    n.output[i] = n.input[i];
                static if (0)
                {
                    if (pvs != n.output[i])
                    {
                        printf("pvs    %s: ", obstate.vars[i].toChars()); pvs.print(obstate.vars[]);
                        printf("output %s: ", obstate.vars[i].toChars()); n.output[i].print(obstate.vars[]);
                    }
                }
                changes = changes || pvs != n.output[i];
            }
        }
    } while (changes);

    static if (log)
    {
        foreach (obi, ob; obstate.nodes)
        {
            printf("%d: %s\n", obi, ob.exp ? ob.exp.toChars() : "".ptr);
            printf("  input:\n");
            foreach (i, ref pvs2; ob.input[])
            {
                printf("    %s: ", obstate.vars[i].toChars()); pvs2.print(obstate.vars[]);
            }

            printf("  output:\n");
            foreach (i, ref pvs2; ob.output[])
            {
                printf("    %s: ", obstate.vars[i].toChars()); pvs2.print(obstate.vars[]);
            }
        }
        printf("\n");
    }
}


/***************************************
 * Check for Ownership/Borrowing errors.
 */
void checkObErrors(ref ObState obstate)
{
    enum log = false;
    if (log)
        printf("checkObErrors()\n");

    void dgWriteVar(ObNode* ob, PtrVarState[] cpvs, VarDeclaration v, Expression e)
    {
        if (log) printf("dgWriteVar() %s\n", v.toChars());
        const vi = obstate.vars.find(v);
        assert(vi != size_t.max);
        PtrVarState* pvs = &cpvs[vi];
        if (e)
        {
            if (isBorrowedPtr(v))
                pvs.state = PtrState.Borrowed;
            else if (isReadonlyPtr(v))
                pvs.state = PtrState.Readonly;
            else
                pvs.state = PtrState.Owner;
            pvs.deps.zero();

            EscapeByResults er;
            escapeByValue(e, &er);

            void by(VarDeclaration r)   // `r` is the rvalue
            {
                const ri = obstate.vars.find(r);
                if (ri == size_t.max)
                    return;

                with (PtrState)
                {
                    pvs.deps[ri] = true;         // v took from r
                    auto pvsr = &cpvs[ri];

                    if (pvsr.state == Undefined)
                    {
                        v.error(e.loc, "is reading from `%s` which is Undefined", r.toChars());
                    }
                    else if (isBorrowedPtr(v))  // v is going to borrow from r
                    {
                        if (pvsr.state == Lent)
                            v.error(e.loc, "is borrowing from `%s` which is Lent", r.toChars());
                        else if (pvsr.state == View)
                            v.error(e.loc, "is borrowing from `%s` which is View", r.toChars());
                        else if (pvsr.state == Readonly)
                            v.error(e.loc, "is borrowing from `%s` which is Readonly", r.toChars());

                        pvs.state = Borrowed;
                        pvs.deps[ri] = true;    // v borrowed from r

                        pvsr.state = Lent;
                        pvsr.deps[vi] = true;        // r was lent to v
                    }
                    else if (isReadonlyPtr(v))
                    {
                        if (pvsr.state == Lent)
                            v.error(e.loc, "is taking a constant from `%s` which is Lent", r.toChars());
                        else if (pvsr.state == Borrowed)
                            v.error(e.loc, "is taking a constant from `%s` which is Borrowed", r.toChars());
                        else if (pvsr.state == Readonly)
                            pvs.deps.or(pvsr.deps);

                        pvs.state = Readonly;
                        pvs.deps[ri] = true;    // v is from r

                        if (pvsr.state != Readonly)
                            pvsr.state = View;
                    }
                    else
                    {
                        // move from r to v
                        pvsr.state = Undefined;
                        pvsr.deps.zero();
                        /* Perhaps move every one who borrowed from r to
                         * borrowing from v?
                         */
                    }
                }
            }

            foreach (VarDeclaration v2; er.byvalue)
                by(v2);
            foreach (VarDeclaration v2; er.byref)
                by(v2);
        }
        else
        {
            pvs.state = PtrState.Undefined;
            pvs.deps.zero();
        }
    }

    void dgReadVar(const ref Loc loc, ObNode* ob, PtrVarState[] cpvs, VarDeclaration v)
    {
        if (log) printf("dgReadVar() %s\n", v.toChars());
        const i = obstate.vars.find(v);
        assert(i != size_t.max);
        auto pvs = &cpvs[i];
        switch (pvs.state)
        {
            case PtrState.Undefined:
                v.error(loc, "has undefined state and cannot be read");
                break;

            case PtrState.Lent:
                pvs.state = PtrState.Owner;
                pvs.deps.zero();        // borrowers become invalid
                break;

            case PtrState.Owner:
            case PtrState.View:
                break;

            case PtrState.Borrowed:
                foreach (j; 0 .. pvs.deps.length)
                {
                    if (pvs.deps[j])
                    {
                        auto pvsr = &cpvs[j];
                        if (pvsr.state != PtrState.Lent ||
                            !pvsr.deps[i])
                        {
                            const r = obstate.vars[j];
                            v.error(loc, "no longer has a valid borrow from `%s`", r.toChars());
                        }
                    }
                }
                break;

            case PtrState.Readonly:
                foreach (j; 0 .. pvs.deps.length)
                {
                    if (pvs.deps[j])
                    {
                        auto pvsr = &cpvs[j];
                        if (pvsr.state != PtrState.View ||
                            !pvsr.deps[i])
                        {
                            const r = obstate.vars[j];
                            v.error(loc, "no longer has a valid constant copy from `%s`", r.toChars());
                        }
                    }
                }
                break;

            default:
                assert(0);
        }
    }

    void foreachExp(ObNode* ob, Expression e, PtrVarState[] cpvs)
    {
        extern (C++) final class ExpWalker : Visitor
        {
            alias visit = typeof(super).visit;
            extern (D) void delegate(const ref Loc loc, ObNode* ob, PtrVarState[] cpvs, VarDeclaration v) dgReadVar;
            extern (D) void delegate(ObNode*, PtrVarState[], VarDeclaration, Expression) dgWriteVar;
            PtrVarState[] cpvs;
            ObNode* ob;
            ObState* obstate;

            extern (D) this(void delegate(const ref Loc loc, ObNode* ob, PtrVarState[] cpvs, VarDeclaration v) dgReadVar,
                            void delegate(ObNode*, PtrVarState[], VarDeclaration, Expression) dgWriteVar,
                            PtrVarState[] cpvs, ObNode* ob, ref ObState obstate)
            {
                this.dgReadVar  = dgReadVar;
                this.dgWriteVar = dgWriteVar;
                this.cpvs = cpvs;
                this.ob = ob;
                this.obstate = &obstate;
            }

            override void visit(Expression)
            {
            }

            override void visit(DeclarationExp e)
            {
                void Dsymbol_visit(Dsymbol s)
                {
                    if (auto vd = s.isVarDeclaration())
                    {
                        s = s.toAlias();
                        if (s != vd)
                            return Dsymbol_visit(s);
                        if (!isTrackableVar(vd))
                            return;

                        auto ei = vd._init ? vd._init.isExpInitializer() : null;
                        dgWriteVar(ob, cpvs, vd, ei ? ei.exp : null);
                    }
                    else if (auto td = s.isTupleDeclaration())
                    {
                        foreach (o; *td.objects)
                        {
                            if (auto eo = o.isExpression())
                            {
                                if (auto se = eo.isDsymbolExp())
                                {
                                    Dsymbol_visit(se.s);
                                }
                            }
                        }
                    }
                }

                Dsymbol_visit(e.declaration);
            }

            override void visit(AssignExp ae)
            {
                ae.e2.accept(this);
                if (auto ve = ae.e1.isVarExp())
                {
                    if (auto v = ve.var.isVarDeclaration())
                        if (isTrackableVar(v))
                            dgWriteVar(ob, cpvs, v, ae.e2);
                }
                else
                    ae.e1.accept(this);
            }

            override void visit(VarExp ve)
            {
                //printf("VarExp: %s\n", ve.toChars());
                if (auto v = ve.var.isVarDeclaration())
                    if (isTrackableVar(v))
                    {
                        dgReadVar(ve.loc, ob, cpvs, v);
                    }
            }

            override void visit(CallExp ce)
            {
                ce.e1.accept(this);
                auto t = ce.e1.type.toBasetype();
                auto tf = t.isTypeFunction();
                if (!tf)
                {
                    assert(t.ty == Tdelegate);
                    tf = t.nextOf().isTypeFunction();
                    assert(tf);
                }

                // j=1 if _arguments[] is first argument
                const int j = tf.isDstyleVariadic();
                bool hasOut;
                const varStackSave = obstate.varStack.length;

                foreach (const i, arg; (*ce.arguments)[])
                {
                    arg.accept(this);
                    if (i - j < tf.parameterList.length &&
                        i >= j)
                    {
                        Parameter p = tf.parameterList[i - j];

                        EscapeByResults er;
                        escapeByValue(arg, &er);

                        void by(VarDeclaration v)
                        {
                            if (!isTrackableVar(v))
                                return;

                            const vi = obstate.vars.find(v);
                            if (vi == size_t.max)
                                return;

                            auto pvs = &cpvs[vi];

                            if (p.storageClass & STC.out_)
                            {
                                hasOut = true;
                                pvs.state = PtrState.Undefined;
                                pvs.deps.zero();
                            }
                            else if (p.storageClass & STC.scope_)
                            {
                                auto t = p.type.toBasetype();
                                if (!t.nextOf() && t.isMutable() || t.nextOf().isMutable())
                                {
                                    // borrow from v
                                    if (pvs.state == PtrState.Owner)
                                    {
                                        pvs.state = PtrState.Borrowed;
                                        pvs.deps.zero();
                                        obstate.varStack.push(vi);
                                    }
                                    else
                                        v.error(arg.loc, "is not Owner, cannot borrow from it");
                                }
                                else
                                {
                                    // readonly
                                    // borrow from v
                                    if (pvs.state == PtrState.Owner)
                                    {
                                        pvs.state = PtrState.Readonly;
                                        pvs.deps.zero();
                                        obstate.varStack.push(vi);
                                    }
                                    else if (pvs.state == PtrState.Readonly)
                                        obstate.varStack.push(vi);
                                    else
                                        v.error(arg.loc, "is not Owner, cannot take readonly view of it");
                                }
                            }
                            else
                            {
                                // move (i.e. consuming arg)
                                if (pvs.state == PtrState.Owner)
                                {
                                    pvs.state = PtrState.Undefined;
                                    pvs.deps.zero();
                                }
                                else
                                    v.error(arg.loc, "is not Owner, cannot consume its value");
                            }
                        }

                        foreach (VarDeclaration v2; er.byvalue)
                            by(v2);
                        foreach (VarDeclaration v2; er.byref)
                            by(v2);
                    }
                }

                /* Reset variables that were borrowed by the function call
                 */
                foreach (i; varStackSave .. obstate.varStack.length)
                {
                    auto pvs = &cpvs[i];
                    if (pvs.state == PtrState.Borrowed ||
                        pvs.state == PtrState.Readonly && !pvs.deps.isZero())
                    {
                        pvs.state = PtrState.Owner;
                        pvs.deps.zero();
                    }
                }
                obstate.varStack.setDim(varStackSave);

                if (hasOut)
                    // Initialization of out's only happens after the function call
                    foreach (const i, arg; (*ce.arguments)[])
                    {
                        if (i - j < tf.parameterList.length &&
                            i >= j)
                        {
                            Parameter p = tf.parameterList[i - j];
                            if (p.storageClass & STC.out_)
                            {
                                if (auto v = isTrackableVarExp(arg))
                                    dgWriteVar(ob, cpvs, v, null);
                            }
                        }
                    }
            }

            override void visit(SymOffExp e)
            {
                if (auto v = e.var.isVarDeclaration())
                    if (isTrackableVar(v))
                    {
                        dgReadVar(e.loc, ob, cpvs, v);
                    }
            }

            override void visit(LogicalExp e)
            {
                e.e1.accept(this);

                const vlen = obstate.vars.length;
                auto p = cast(PtrVarState*)mem.xcalloc(vlen, PtrVarState.sizeof);
                PtrVarState[] out1 = p[0 .. vlen];
                foreach (i, ref pvs; out1)
                {
                    pvs = cpvs[i];
                }

                e.e2.accept(this);

                // Merge out1 into cpvs
                foreach (i; 0 .. vlen)
                {
                    cpvs[i].combine(out1[i]);
                }

                mem.xfree(p); // should free .deps too
            }

            override void visit(CondExp e)
            {
                e.econd.accept(this);

                const vlen = obstate.vars.length;
                auto p = cast(PtrVarState*)mem.xcalloc(vlen, PtrVarState.sizeof);
                PtrVarState[] out1 = p[0 .. vlen];
                foreach (i, ref pvs; out1)
                {
                    pvs = cpvs[i];
                }

                e.e1.accept(this);

                // Swap out1 with cpvs
                foreach (i; 0 .. vlen)
                {
                    out1[i].deps.swap(cpvs[i].deps);
                    const state = out1[i].state;
                    out1[i].state = cpvs[i].state;
                    cpvs[i].state = state;
                }

                e.e2.accept(this);

                // Merge out1 into cpvs
                foreach (i; 0 .. vlen)
                {
                    cpvs[i].combine(out1[i]);
                }

                mem.xfree(p); // should free .deps too
            }

            override void visit(AddrExp e)
            {
                /* Taking the address of struct literal is normally not
                 * allowed, but CTFE can generate one out of a new expression,
                 * but it'll be placed in static data so no need to check it.
                 */
                if (e.e1.op != TOK.structLiteral)
                    e.e1.accept(this);
            }

            override void visit(UnaExp e)
            {
                e.e1.accept(this);
            }

            override void visit(BinExp e)
            {
                e.e1.accept(this);
                e.e2.accept(this);
            }

            override void visit(ArrayLiteralExp e)
            {
                Type tb = e.type.toBasetype();
                if (tb.ty == Tsarray || tb.ty == Tarray)
                {
                    if (e.basis)
                        e.basis.accept(this);
                    foreach (el; *e.elements)
                    {
                        if (el)
                            el.accept(this);
                    }
                }
            }

            override void visit(StructLiteralExp e)
            {
                if (e.elements)
                {
                    foreach (ex; *e.elements)
                    {
                        if (ex)
                            ex.accept(this);
                    }
                }
            }

            override void visit(AssocArrayLiteralExp e)
            {
                if (e.keys)
                {
                    foreach (i, key; *e.keys)
                    {
                        if (key)
                            key.accept(this);
                        if (auto value = (*e.values)[i])
                            value.accept(this);
                    }
                }
            }

            override void visit(NewExp e)
            {
                Type tb = e.newtype.toBasetype();
                if (e.arguments)
                {
                    foreach (ex; *e.arguments)
                    {
                        if (ex)
                            ex.accept(this);
                    }
                }
            }

            override void visit(SliceExp e)
            {
                e.e1.accept(this);
                if (e.lwr)
                    e.lwr.accept(this);
                if (e.upr)
                    e.upr.accept(this);
            }
        }

        if (e)
        {
            scope ExpWalker ew = new ExpWalker(&dgReadVar, &dgWriteVar, cpvs, ob, obstate);
            e.accept(ew);
        }
    }

    const vlen = obstate.vars.length;
    auto p = cast(PtrVarState*)mem.xcalloc(vlen, PtrVarState.sizeof);
    PtrVarState[] cpvs = p[0 .. vlen];
    foreach (ref pvs; cpvs)
        pvs.deps.length = vlen;

    foreach (obi, ob; obstate.nodes)
    {
        static if (log)
        {
            printf("%d: %s\n", obi, ob.exp ? ob.exp.toChars() : "".ptr);
            printf("  input:\n");
            foreach (i, ref pvs; ob.input[])
            {
                printf("    %s: ", obstate.vars[i].toChars()); pvs.print(obstate.vars[]);
            }
        }

        /* Combine the .output[]s of each ob.preds[] looking for errors
         */
        if (obi)   // skip startnode
        {
            foreach (i; 0 .. vlen)
            {
                foreach (j; 0 .. ob.preds.length)
                {
                    auto pvs1 = &cpvs[0];
                    auto pvs2 = &ob.preds[j].output[i];
                    if (j == 0)
                        *pvs1 = *pvs2;
                    else
                    {
                        const s1 = pvs1.state;
                        const s2 = pvs2.state;
                        if (s1 != s2 && (s1 == PtrState.Owner || s2 == PtrState.Owner))
                        {
                            auto v = obstate.vars[i];
                            v.error(ob.exp ? ob.exp.loc : v.loc, "is both %s and %s", s1.toChars(), s2.toChars());
                        }
                        pvs1.combine(*pvs2);
                    }
                }
            }
        }

        foreach (i, ref pvs; ob.input)
        {
            cpvs[i] = pvs;
        }
        foreachExp(ob, ob.exp, cpvs);

        static if (log)
        {
            printf("  output:\n");
            foreach (i, ref pvs; ob.output[])
            {
                printf("    %s: ", obstate.vars[i].toChars()); pvs.print(obstate.vars[]);
            }
        }

        if (ob.obtype == ObType.retexp)
        {
            EscapeByResults er;
            escapeByValue(ob.exp, &er);

            void by(VarDeclaration r)   // `r` is the rvalue
            {
                const ri = obstate.vars.find(r);
                if (ri == size_t.max)
                    return;
                with (PtrState)
                {
                    auto pvsr = &ob.output[ri];
                    switch (pvsr.state)
                    {
                        case Undefined:
                            r.error(ob.exp.loc, "is returned but is Undefined");
                            break;

                        case Lent:
                            break;

                        case View:
                            break;

                        case Owner:
                            pvsr.state = Undefined;     // returning a pointer "consumes" it
                            break;

                        case Borrowed:
                        case Readonly:
                            break;

                        default:
                            assert(0);
                    }
                }
            }

            foreach (VarDeclaration v2; er.byvalue)
                by(v2);
            foreach (VarDeclaration v2; er.byref)
                by(v2);
        }

        if (ob.obtype == ObType.return_ || ob.obtype == ObType.retexp)
        {
            foreach (i, ref pvs; ob.output[])
            {
                //printf("%s: ", obstate.vars[i].toChars()); pvs.print(obstate.vars[]);
                if (pvs.state == PtrState.Owner)
                {
                    auto v = obstate.vars[i];
                    v.error(v.loc, "is left dangling at return");
                }
            }
        }
    }
}
